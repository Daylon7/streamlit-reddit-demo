"""
Reddit WSB Sentiment Analysis - Streamlit App
Aplicaci√≥n web para interactuar con la API de predicciones
"""

import streamlit as st
import requests
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import time
import json

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title="Reddit WSB Sentiment Analysis",
    page_icon="üöÄ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Configuraci√≥n de la API
API_BASE_URL = "https://daylong-datalab-reddit.hf.space"  # Cambiar por tu URL real

# T√≠tulos y descripci√≥n
st.markdown("<h1 style='text-align: center;'>üìà Reddit WSB Sentiment Analysis</h1>", unsafe_allow_html=True)
st.markdown("<br>", unsafe_allow_html=True)
st.markdown("**An√°lisis de sentimiento y predicci√≥n de retornos financieros con datos actualizados**")

# Sidebar para configuraci√≥n
api_url = API_BASE_URL

# Verificar conexi√≥n con la API
@st.cache_data(ttl=60)
def check_api_health(api_url):
    """Verificar si la API est√° funcionando"""
    try:
        response = requests.get(f"{api_url}/health", timeout=10)
        if response.status_code == 200:
            return True, response.json()
        else:
            return False, None
    except:
        return False, None

# Verificar API
with st.spinner("Verificando conexi√≥n con la API..."):
    api_healthy, health_data = check_api_health(api_url)

if api_healthy:
    st.success("‚úÖ API conectada correctamente")
    if health_data:
        st.info(' ‚úÖ Modelo cargado correctamente ' if health_data.get('model_loaded') else '‚ùå')
else:
    st.error("‚ùå No se pudo conectar con la API.")
    st.stop()

# Funci√≥n para hacer predicciones
@st.cache_data(ttl=600)  # Cache por 10 minutos
def get_prediction(symbol, include_sentiment=True):
    """Obtener predicci√≥n de la API"""
    try:
        response = requests.get(
            f"{api_url}/predict/{symbol}",
            params={"include_sentiment": include_sentiment},
            timeout=30
        )
        if response.status_code == 200:
            return response.json()
        else:
            return None
    except Exception as e:
        st.error(f"Error obteniendo predicci√≥n: {e}")
        return None

# Funci√≥n para obtener informaci√≥n del modelo
@st.cache_data(ttl=3600)  # Cache por 1 hora
def get_model_info():
    """Obtener informaci√≥n del modelo"""
    try:
        response = requests.get(f"{api_url}/model/info", timeout=10)
        if response.status_code == 200:
            return response.json()
        else:
            return None
    except:
        return None

# Funci√≥n para obtener informaci√≥n detallada de una acci√≥n
@st.cache_data(ttl=600)  # Cache por 10 minutos
def get_stock_info(symbol):
    """Obtener informaci√≥n detallada de una acci√≥n"""
    try:
        response = requests.get(f"{api_url}/stock/{symbol}/info", timeout=10)
        if response.status_code == 200:
            return response.json()
        else:
            return None
    except:
        return None

# Funci√≥n para obtener indicadores t√©cnicos
@st.cache_data(ttl=300)  # Cache por 5 minutos
def get_technical_indicators(symbol):
    """Obtener indicadores t√©cnicos de una acci√≥n"""
    try:
        response = requests.get(f"{api_url}/stock/{symbol}/indicators", timeout=10)
        if response.status_code == 200:
            return response.json()
        else:
            return None
    except:
        return None

# Funci√≥n para obtener an√°lisis de sentimiento de Reddit
@st.cache_data(ttl=300)  # Cache por 5 minutos
def get_reddit_sentiment(symbol, limit=100):
    """Obtener an√°lisis de sentimiento de Reddit"""
    try:
        response = requests.get(f"{api_url}/reddit/{symbol}/sentiment", 
                              params={"limit": limit}, timeout=15)
        if response.status_code == 200:
            return response.json()
        else:
            return None
    except:
        return None

# Funci√≥n para obtener an√°lisis comprehensivo de m√∫ltiples subreddits
@st.cache_data(ttl=300)  # Cache por 5 minutos
def get_comprehensive_reddit_analysis(symbol, subreddits="wallstreetbets,investing,stocks", limit=100):
    """Obtener an√°lisis comprehensivo de m√∫ltiples subreddits"""
    try:
        response = requests.get(f"{api_url}/reddit/{symbol}/comprehensive", 
                              params={"subreddits": subreddits, "limit": limit}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            return None
    except:
        return None

# Funci√≥n para obtener subreddits disponibles
@st.cache_data(ttl=3600)  # Cache por 1 hora
def get_available_subreddits():
    """Obtener lista de subreddits disponibles"""
    try:
        response = requests.get(f"{api_url}/reddit/subreddits/available", timeout=10)
        if response.status_code == 200:
            return response.json()
        else:
            return None
    except:
        return None

# Funci√≥n para analizar texto individual
@st.cache_data(ttl=60)  # Cache por 1 minuto
def analyze_text_api(text):
    """Analizar texto individual usando la API"""
    try:
        response = requests.post(f"{api_url}/reddit/analyze-text", 
                              params={"text": text}, timeout=15)
        if response.status_code == 200:
            return response.json()
        else:
            return None
    except:
        return None

# Funci√≥n para obtener posts de Reddit
@st.cache_data(ttl=300)  # Cache por 5 minutos
def get_reddit_posts(symbol, limit=20):
    """Obtener posts populares de Reddit"""
    try:
        response = requests.get(f"{api_url}/reddit/{symbol}/posts", 
                              params={"limit": limit}, timeout=15)
        if response.status_code == 200:
            return response.json()
        else:
            return None
    except:
        return None

# Funci√≥n para obtener datos hist√≥ricos mejorados
@st.cache_data(ttl=300)  # Cache por 5 minutos
def get_historical_data_api(symbol, period="30d", interval="1d"):
    """Obtener datos hist√≥ricos usando la API"""
    try:
        response = requests.get(f"{api_url}/stock/{symbol}/history", 
                              params={"period": period, "interval": interval}, timeout=15)
        if response.status_code == 200:
            return response.json()
        else:
            return None
    except:
        return None

# Funci√≥n para obtener datos hist√≥ricos
def get_historical_data(symbol, days=30):
    """Obtener datos hist√≥ricos usando yfinance"""
    try:
        import yfinance as yf
        ticker = yf.Ticker(symbol)
        hist = ticker.history(period=f"{days}d")
        return hist
    except:
        return None

# Inicializar estado de sesi√≥n para mantener la pesta√±a activa
if 'active_tab' not in st.session_state:
    st.session_state.active_tab = 0

# Selector de pesta√±as usando radio buttons (m√°s confiable para mantener estado)
tab_options = [
    "üîÆ Predicciones", 
    "üìä An√°lisis", 
    "üìà Gr√°ficos", 
    "üè¢ Informaci√≥n de Acci√≥n",
    "üì± Reddit Sentiment",
    "üìù An√°lisis de Texto",
    "‚ÑπÔ∏è Informaci√≥n"
]

# Crear selector de pesta√±as horizontal
selected_tab = st.radio(
    "Seleccionar secci√≥n:",
    options=tab_options,
    index=st.session_state.active_tab,
    horizontal=True,
    key="tab_selector"
)

# Actualizar el estado de la pesta√±a activa
st.session_state.active_tab = tab_options.index(selected_tab)

# Separador visual
st.markdown("---")

# Mostrar contenido basado en la pesta√±a seleccionada
if selected_tab == "üîÆ Predicciones":
    st.header("Predicciones en Tiempo Real")
    
    # Input del usuario
    symbol = st.text_input(
        "S√≠mbolo de la acci√≥n",
        value="TSLA",
        placeholder="Ej: AAPL (Apple), TSLA (Tesla), MSFT (Microsoft Corporation), GOOGL (Google)",
        help="Ingresa el s√≠mbolo de la acci√≥n que quieres analizar, puede apoyarse seleccionando el simbolo con el que cotiza la empresa en la barra de busqueda"
    ).upper()

    include_sentiment = st.checkbox(
        "Incluir sentimiento de Reddit",
        value=True,
        help="Incluir an√°lisis de sentimiento de Reddit"
    )
    # Bot√≥n para hacer predicci√≥n
    if st.button("üìà Hacer Predicci√≥n", type="primary"):
        if symbol:
            with st.spinner(f"Analizando {symbol}..."):
                prediction_data = get_prediction(symbol, include_sentiment)
                
                if prediction_data:
                    # Mostrar resultados
                    st.success("‚úÖ Predicci√≥n completada")
                    
                    # M√©tricas principales
                    col1, col2, col3 = st.columns(3)
                    
                    with col1:
                        st.metric(
                            "Predicci√≥n (%)",
                            f"{prediction_data['prediction_percent']:.2f}%",
                            delta=f"{prediction_data['prediction_percent']:.2f}%"
                        )
                    
                    with col2:
                        st.metric(
                            "S√≠mbolo",
                            prediction_data['symbol'],
                            help="S√≠mbolo analizado"
                        )
                    
                    with col3:
                        st.metric(
                            "Timestamp",
                            prediction_data['timestamp'][:19],
                            help="Hora de la predicci√≥n"
                        )
                    
                    # Informaci√≥n adicional
                    st.subheader("üìã Detalles de la Predicci√≥n")
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.json({
                            "Predicci√≥n (log return)": f"{prediction_data['prediction']:.6f}",
                            "Predicci√≥n (%)": f"{prediction_data['prediction_percent']:.2f}%",
                            "S√≠mbolo": prediction_data['symbol'],
                            "Mensaje": prediction_data.get('message', 'N/A')
                        })
                    with col2:
                        st.json(prediction_data['data_sources'])
                        
                        # Mostrar estado de fuentes de datos
                        st.subheader("üîç Estado de Fuentes de Datos")
                        if prediction_data['data_sources'].get('financial'):
                            st.success("‚úÖ Datos financieros disponibles")
                        if prediction_data['data_sources'].get('reddit_sentiment'):
                            st.success("‚úÖ An√°lisis de sentimiento Reddit disponible")
                        else:
                            st.warning("‚ö†Ô∏è An√°lisis de sentimiento Reddit no disponible")
                        if prediction_data['data_sources'].get('technical_indicators'):
                            st.success("‚úÖ Indicadores t√©cnicos calculados")
                    
                    # Medidor tipo term√≥metro para la predicci√≥n
                    st.subheader("üå°Ô∏è Medidor de Predicci√≥n")
                    pred_pct = prediction_data['prediction_percent']
                    
                    # Crear medidor tipo term√≥metro usando componentes nativos de Streamlit
                    def create_thermometer_gauge(value, symbol):
                        """Crear medidor tipo term√≥metro para mostrar predicci√≥n"""
                        # Normalizar el valor entre -10 y 10 para el medidor
                        normalized_value = max(-10, min(10, value))
                        
                        # Determinar color y emoji basado en el valor
                        if normalized_value > 2:
                            color = "#28a745"  # Verde fuerte
                            emoji = "üî•"
                            sentiment = "MUY BULLISH"
                        elif normalized_value > 0:
                            color = "#20c997"  # Verde claro
                            emoji = "üìà"
                            sentiment = "BULLISH"
                        elif normalized_value > -2:
                            color = "#ffc107"  # Amarillo
                            emoji = "üìâ"
                            sentiment = "BEARISH"
                        else:
                            color = "#dc3545"  # Rojo
                            emoji = "‚ùÑÔ∏è"
                            sentiment = "MUY BEARISH"
                        
                        # Crear el medidor visual
                        col1, col2, col3 = st.columns([1, 2, 1])
                        
                        with col2:
                            # T√≠tulo del medidor
                            st.markdown(f"<h3 style='text-align: center; margin-bottom: 10px;'>{emoji} {sentiment}</h3>", unsafe_allow_html=True)
                            
                            # Crear barra de progreso que simula un term√≥metro
                            progress_value = (normalized_value + 10) / 20  # Convertir a 0-1
                            st.progress(progress_value)
                            
                            # Mostrar valor num√©rico
                            st.markdown(f"<h2 style='text-align: center; color: {color}; margin: 10px 0;'>{value:.2f}%</h2>", unsafe_allow_html=True)
                            
                            # Indicadores de temperatura
                            col_temp1, col_temp2, col_temp3, col_temp4, col_temp5 = st.columns(5)
                            
                            with col_temp1:
                                st.markdown("<div style='text-align: center; font-size: 12px; color: #dc3545;'>‚ùÑÔ∏è<br/>-10%</div>", unsafe_allow_html=True)
                            with col_temp2:
                                st.markdown("<div style='text-align: center; font-size: 12px; color: #ffc107;'>üìâ<br/>-2%</div>", unsafe_allow_html=True)
                            with col_temp3:
                                st.markdown("<div style='text-align: center; font-size: 12px; color: #6c757d;'>üìä<br/>0%</div>", unsafe_allow_html=True)
                            with col_temp4:
                                st.markdown("<div style='text-align: center; font-size: 12px; color: #20c997;'>üìà<br/>+2%</div>", unsafe_allow_html=True)
                            with col_temp5:
                                st.markdown("<div style='text-align: center; font-size: 12px; color: #28a745;'>üî•<br/>+10%</div>", unsafe_allow_html=True)
                    
                    # Mostrar el medidor
                    create_thermometer_gauge(pred_pct, symbol)
                    
                    # Interpretaci√≥n
                    st.subheader("üí° Interpretaci√≥n")
                    
                    if pred_pct > 2:
                        st.success(f"üìà **Tendencia Alcista Fuerte**: {symbol} podr√≠a subir {pred_pct:.2f}%")
                    elif pred_pct > 0:
                        st.info(f"üìà **Tendencia Alcista**: {symbol} podr√≠a subir {pred_pct:.2f}%")
                    elif pred_pct > -2:
                        st.warning(f"üìâ **Tendencia Bajista**: {symbol} podr√≠a bajar {abs(pred_pct):.2f}%")
                    else:
                        st.error(f"üìâ **Tendencia Bajista Fuerte**: {symbol} podr√≠a bajar {abs(pred_pct):.2f}%")
                    
                    # Advertencia
                    st.warning("‚ö†Ô∏è **Advertencia**: Estas predicciones son solo para fines educativos y no constituyen consejos de inversi√≥n.")
                    
                else:
                    st.error("‚ùå No se pudo obtener la predicci√≥n. Verifica el s√≠mbolo y la conexi√≥n.")
        else:
            st.warning("‚ö†Ô∏è Por favor ingresa un s√≠mbolo v√°lido.")

elif selected_tab == "üìä An√°lisis":
    st.header("An√°lisis Comparativo")
    
    # M√∫ltiples s√≠mbolos
    st.subheader("Comparar M√∫ltiples Acciones")
    
    symbols_input = st.text_input(
        "S√≠mbolos separados por comas",
        value="AAPL,TSLA,MSFT,GOOGL,NVDA",
        help="Ej: AAPL,TSLA,MSFT,GOOGL,NVDA"
    )
    
    if st.button("ÔøΩÔøΩ Analizar M√∫ltiples", type="primary"):
        symbols = [s.strip().upper() for s in symbols_input.split(",") if s.strip()]
        
        if symbols:
            with st.spinner("Analizando m√∫ltiples acciones..."):
                predictions = []
                
                for symbol in symbols:
                    pred_data = get_prediction(symbol, True)  # Incluir sentimiento por defecto
                    stock_info = get_stock_info(symbol)
                    if pred_data:
                        # Crear informaci√≥n de la acci√≥n
                        stock_info_text = "‚ùå Informaci√≥n no disponible"
                        if stock_info:
                            company_name = stock_info.get('company_name', 'N/A')
                            sector = stock_info.get('sector', 'N/A')
                            current_price = stock_info.get('current_price', 0)
                            market_cap = stock_info.get('market_cap')
                            
                            # Formatear capitalizaci√≥n de mercado
                            if market_cap:
                                if market_cap >= 1e12:
                                    market_cap_str = f"${market_cap/1e12:.1f}T"
                                elif market_cap >= 1e9:
                                    market_cap_str = f"${market_cap/1e9:.1f}B"
                                elif market_cap >= 1e6:
                                    market_cap_str = f"${market_cap/1e6:.1f}M"
                                else:
                                    market_cap_str = f"${market_cap:,.0f}"
                            else:
                                market_cap_str = "N/A"
                            
                            # Construir informaci√≥n de forma m√°s robusta
                            info_parts = []
                            if company_name != 'N/A':
                                info_parts.append(f"üè¢ {company_name}")
                            if sector != 'N/A':
                                info_parts.append(f"üìä {sector}")
                            if current_price > 0:
                                info_parts.append(f"üí∞ ${current_price:.2f}")
                            if market_cap_str != 'N/A':
                                info_parts.append(f"üìà {market_cap_str}")
                            
                            stock_info_text = "\n".join(info_parts) if info_parts else "‚ùå Informaci√≥n no disponible"
                        
                        predictions.append({
                            "S√≠mbolo": symbol,
                            "Informaci√≥n de la Acci√≥n": stock_info_text,
                            "Predicci√≥n (%)": pred_data['prediction_percent'],
                            "Timestamp": pred_data['timestamp'][:19]
                        })
                
                if predictions:
                    df = pd.DataFrame(predictions)
                    
                    # Mostrar tabla
                    st.subheader("üìã Resultados Comparativos")
                    st.dataframe(df, use_container_width=True)
                    
                    # Gr√°fico de barras
                    fig = px.bar(
                        df, 
                        x="S√≠mbolo", 
                        y="Predicci√≥n (%)",
                        title="Predicciones por S√≠mbolo",
                        color="Predicci√≥n (%)",
                        color_continuous_scale="RdYlGn"
                    )
                    st.plotly_chart(fig, use_container_width=True)
                    
                    # Ranking
                    st.subheader("üèÜ Ranking de Predicciones")
                    df_sorted = df.sort_values("Predicci√≥n (%)", ascending=False)
                    
                    for i, (_, row) in enumerate(df_sorted.iterrows(), 1):
                        emoji = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else "üìä"
                        st.write(f"{emoji} **{i}.** {row['S√≠mbolo']}: {row['Predicci√≥n (%)']:.2f}%")
                else:
                    st.error("‚ùå No se pudieron obtener predicciones para ning√∫n s√≠mbolo.")

elif selected_tab == "üìà Gr√°ficos":
    st.header("üìà Visualizaciones Avanzadas")
    
    # Selector de s√≠mbolo para gr√°ficos
    col1, col2, col3 = st.columns([2, 1, 1])
    
    with col1:
        chart_symbol = st.selectbox(
            "Seleccionar s√≠mbolo para gr√°ficos",
            ["AAPL", "TSLA", "MSFT", "GOOGL", "NVDA", "AMZN", "META", "GME", "AMC"],
            index=1,
            key="chart_symbol"
        )
    
    with col2:
        period_options = {
            "1 d√≠a": "1d",
            "5 d√≠as": "5d", 
            "1 mes": "1mo",
            "3 meses": "3mo",
            "6 meses": "6mo",
            "1 a√±o": "1y",
            "2 a√±os": "2y",
            "5 a√±os": "5y"
        }
        selected_period = st.selectbox(
            "Per√≠odo",
            list(period_options.keys()),
            index=3,  # Default to 3 months
            key="period_selector"
        )
        period_value = period_options[selected_period]
    
    with col3:
        interval_options = {
            "1 d√≠a": "1d",
            "1 hora": "1h",
            "30 min": "30m",
            "15 min": "15m",
            "5 min": "5m"
        }
        selected_interval = st.selectbox(
            "Intervalo",
            list(interval_options.keys()),
            index=0,  # Default to 1 day
            key="interval_selector"
        )
        interval_value = interval_options[selected_interval]
    
    # Obtener datos hist√≥ricos usando la nueva API
    if st.button("üìä Actualizar Gr√°ficos", type="primary", key="update_charts"):
        with st.spinner("Obteniendo datos hist√≥ricos..."):
            hist_data_api = get_historical_data_api(chart_symbol, period_value, interval_value)
            hist_data_yf = get_historical_data(chart_symbol, days=30)  # Fallback
    
    # Mostrar datos hist√≥ricos si est√°n disponibles
    if 'hist_data_api' in locals() and hist_data_api:
        # Convertir datos de la API a DataFrame para visualizaci√≥n
        hist_df = pd.DataFrame(hist_data_api['data'])
        hist_df['date'] = pd.to_datetime(hist_df['date'])
        hist_df = hist_df.set_index('date')
        
        # Gr√°fico de precios con datos de la API
        st.subheader(f"üìà Precios Hist√≥ricos - {chart_symbol} ({selected_period})")
        
        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=hist_df.index,
            y=hist_df['close'],
            mode='lines',
            name='Precio de Cierre',
            line=dict(color='blue', width=2)
        ))
        
        # Agregar l√≠neas de precio alto y bajo
        fig.add_trace(go.Scatter(
            x=hist_df.index,
            y=hist_df['high'],
            mode='lines',
            name='Precio Alto',
            line=dict(color='green', width=1, dash='dash'),
            opacity=0.7
        ))
        
        fig.add_trace(go.Scatter(
            x=hist_df.index,
            y=hist_df['low'],
            mode='lines',
            name='Precio Bajo',
            line=dict(color='red', width=1, dash='dash'),
            opacity=0.7
        ))
        
        fig.update_layout(
            title=f"Precio de Cierre - {chart_symbol} ({selected_period})",
            xaxis_title="Fecha",
            yaxis_title="Precio ($)",
            hovermode='x unified',
            height=500
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Gr√°fico de volumen
        
        fig_vol = go.Figure()
        fig_vol.add_trace(go.Bar(
            x=hist_df.index,
            y=hist_df['volume'],
            name='Volumen',
            marker_color='lightblue'
        ))
        
        fig_vol.update_layout(
            title=f"Volumen de Trading - {chart_symbol} ({selected_period})",
            xaxis_title="Fecha",
            yaxis_title="Volumen",
            hovermode='x unified',
            height=400
        )
        
        st.plotly_chart(fig_vol, use_container_width=True)
        
        # Estad√≠sticas mejoradas
        st.subheader("üìä Estad√≠sticas Detalladas")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            current_price = hist_df['close'].iloc[-1]
            st.metric("Precio Actual", f"${current_price:.2f}")
            st.metric("Precio Apertura", f"${hist_df['open'].iloc[-1]:.2f}")
        
        with col2:
            change = current_price - hist_df['close'].iloc[0]
            change_pct = (change / hist_df['close'].iloc[0]) * 100
            st.metric("Cambio Total", f"${change:.2f}")
            st.metric("Cambio %", f"{change_pct:.2f}%")
        
        with col3:
            high_price = hist_df['high'].max()
            low_price = hist_df['low'].min()
            st.metric("Precio M√°ximo", f"${high_price:.2f}")
            st.metric("Precio M√≠nimo", f"${low_price:.2f}")
        
        with col4:
            avg_vol = hist_df['volume'].mean()
            total_vol = hist_df['volume'].sum()
            st.metric("Volumen Promedio", f"{avg_vol:,.0f}")
            st.metric("Volumen Total", f"{total_vol:,.0f}")
    
        # Informaci√≥n adicional de la API
        st.subheader("‚ÑπÔ∏è Informaci√≥n de los Datos")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.info(f"**Per√≠odo:** {hist_data_api.get('period', 'N/A')}")
            st.info(f"**Puntos de datos:** {hist_data_api.get('data_points', 'N/A')}")
        
        with col2:
            st.info(f"**Fecha inicio:** {hist_data_api.get('start_date', 'N/A')}")
            st.info(f"**Fecha fin:** {hist_data_api.get('end_date', 'N/A')}")
        
        # Tabla de datos
        with st.expander("üìã Ver Datos Hist√≥ricos Completos"):
            st.dataframe(hist_df, use_container_width=True)
    
    elif 'hist_data_yf' in locals() and hist_data_yf is not None and not hist_data_yf.empty:
        # Fallback a datos de yfinance
        st.warning("‚ö†Ô∏è Usando datos de yfinance como respaldo")
        
        # Gr√°fico de precios
        st.subheader(f"üìà Precios Hist√≥ricos - {chart_symbol} (30 d√≠as)")
        
        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=hist_data_yf.index,
            y=hist_data_yf['Close'],
            mode='lines',
            name='Precio de Cierre',
            line=dict(color='blue', width=2)
        ))
        
        fig.update_layout(
            title=f"Precio de Cierre - {chart_symbol} (30 d√≠as)",
            xaxis_title="Fecha",
            yaxis_title="Precio ($)",
            hovermode='x unified'
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Gr√°fico de volumen
        st.subheader(f"üìä Volumen de Trading - {chart_symbol}")
        
        fig_vol = go.Figure()
        fig_vol.add_trace(go.Bar(
            x=hist_data_yf.index,
            y=hist_data_yf['Volume'],
            name='Volumen',
            marker_color='lightblue'
        ))
        
        fig_vol.update_layout(
            title=f"Volumen de Trading - {chart_symbol} (30 d√≠as)",
            xaxis_title="Fecha",
            yaxis_title="Volumen",
            hovermode='x unified'
        )
        
        st.plotly_chart(fig_vol, use_container_width=True)
        
        # Estad√≠sticas
        st.subheader("üìä Estad√≠sticas")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Precio Actual", f"${hist_data_yf['Close'].iloc[-1]:.2f}")
        
        with col2:
            change = hist_data_yf['Close'].iloc[-1] - hist_data_yf['Close'].iloc[0]
            st.metric("Cambio (30d)", f"${change:.2f}")
        
        with col3:
            change_pct = (change / hist_data_yf['Close'].iloc[0]) * 100
            st.metric("Cambio % (30d)", f"{change_pct:.2f}%")
        
        with col4:
            avg_vol = hist_data_yf['Volume'].mean()
            st.metric("Volumen Promedio", f"{avg_vol:,.0f}")
    
    else:
        st.info("üëÜ Haz clic en 'Actualizar Gr√°ficos' para cargar los datos hist√≥ricos")

elif selected_tab == "üè¢ Informaci√≥n de Acci√≥n":
    st.header("üè¢ Informaci√≥n Detallada de Acci√≥n")
    
    # Input del usuario - ahora en una sola fila
    stock_symbol = st.text_input(
        "S√≠mbolo de la acci√≥n",
        value="AAPL",
        placeholder="Ej: AAPL, TSLA, MSFT, GOOGL",
        help="Ingresa el s√≠mbolo de la acci√≥n que quieres analizar",
        key="stock_info_symbol_tab4"
    ).upper()
    
    # Bot√≥n centrado abajo del input
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("üîç Obtener Informaci√≥n", type="primary", key="get_stock_info_tab4", use_container_width=True):
            if stock_symbol:
                with st.spinner(f"Obteniendo informaci√≥n de {stock_symbol}..."):
                    stock_info = get_stock_info(stock_symbol)
                    technical_indicators = get_technical_indicators(stock_symbol)
    
    # Mostrar informaci√≥n fuera de las columnas para que ocupe todo el ancho
    if 'stock_info' in locals() and stock_info:
        st.success("‚úÖ Informaci√≥n obtenida correctamente")
        
        # Informaci√≥n b√°sica de la empresa - layout de dos columnas
        st.subheader("üìã Informaci√≥n de la Empresa")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.metric("üè¢ Empresa", stock_info.get('company_name', 'N/A'))
            st.metric("üìä S√≠mbolo", stock_info.get('symbol', 'N/A'))
            st.metric("üè≠ Sector", stock_info.get('sector', 'N/A'))
            st.metric("üè¢ Industria", stock_info.get('industry', 'N/A'))
            st.metric("üèõÔ∏è Bolsa", stock_info.get('exchange', 'N/A'))
        
        with col2:
            st.metric("üí± Moneda", stock_info.get('currency', 'N/A'))
            st.metric("üí∞ Precio Actual", f"${stock_info.get('current_price', 0):.2f}")
            
            market_cap = stock_info.get('market_cap')
            if market_cap:
                if market_cap >= 1e12:
                    market_cap_formatted = f"${market_cap/1e12:.1f}T"
                elif market_cap >= 1e9:
                    market_cap_formatted = f"${market_cap/1e9:.1f}B"
                elif market_cap >= 1e6:
                    market_cap_formatted = f"${market_cap/1e6:.1f}M"
                else:
                    market_cap_formatted = f"${market_cap:,.0f}"
                st.metric("üìà Capitalizaci√≥n de Mercado", market_cap_formatted)
            else:
                st.metric("üìà Capitalizaci√≥n de Mercado", "N/A")
            
            st.metric("üïí Timestamp", stock_info.get('timestamp', 'N/A')[:19])
        
        # Indicadores t√©cnicos - layout de dos columnas
        if 'technical_indicators' in locals() and technical_indicators:
            st.subheader("üìä Indicadores T√©cnicos")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.metric("üìà RSI (14)", f"{technical_indicators.get('rsi_14', 0):.2f}")
                st.metric("üìä MACD", f"{technical_indicators.get('macd', 0):.4f}")
                st.metric("üìÖ Fecha", technical_indicators.get('date', 'N/A'))
                st.metric("üìä Volumen SMA", f"{technical_indicators.get('volume_sma', 0):,.0f}")
            
            with col2:
                st.metric("üìâ SMA 20", f"${technical_indicators.get('sma_20', 0):.2f}")
                st.metric("üìà SMA 50", f"${technical_indicators.get('sma_50', 0):.2f}")
                st.metric("üî∫ BB Superior", f"${technical_indicators.get('bollinger_upper', 0):.2f}")
                st.metric("üîª BB Inferior", f"${technical_indicators.get('bollinger_lower', 0):.2f}")
            
            # Interpretaci√≥n de indicadores
            st.subheader("üí° Interpretaci√≥n de Indicadores")
            
            rsi = technical_indicators.get('rsi_14', 50)
            if rsi > 70:
                st.warning("‚ö†Ô∏è RSI indica sobrecompra (>70)")
            elif rsi < 30:
                st.info("‚ÑπÔ∏è RSI indica sobreventa (<30)")
            else:
                st.success("‚úÖ RSI en rango neutral")
            
            macd = technical_indicators.get('macd', 0)
            if macd > 0:
                st.success("üìà MACD positivo - Momentum alcista")
            else:
                st.warning("üìâ MACD negativo - Momentum bajista")
        
        # Informaci√≥n completa en formato JSON
        with st.expander("üìÑ Informaci√≥n Completa (JSON)"):
            st.json(stock_info)
            
            if 'technical_indicators' in locals() and technical_indicators:
                st.json(technical_indicators)

elif selected_tab == "‚ÑπÔ∏è Informaci√≥n":
    st.header("Informaci√≥n del Sistema")
    
    # Informaci√≥n del modelo
    model_info = get_model_info()
    
    if model_info:
        st.subheader("ü§ñ Informaci√≥n del Modelo")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.json({
                "Tipo de Modelo": model_info.get('model_type', 'N/A'),
                "Features": model_info.get('features_count', 'N/A'),
                "Cargado": model_info.get('loaded', False),
                "Versi√≥n": model_info.get('version', 'N/A')
            })
        
        with col2:
            st.success("‚úÖ Modelo XGBoost cargado correctamente")
            st.info(f"üî¢ {model_info.get('features_count', 'N/A')} features utilizadas")
    
    # Informaci√≥n de la API
    st.subheader("üîó Estado de la API")
    
    if health_data:
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Estado", "‚úÖ Saludable")
        
        with col2:
            st.metric("Modelo", "‚úÖ Cargado" if health_data.get('model_loaded') else "‚ùå No cargado")
        
        with col3:
            st.metric("Reddit", "‚úÖ Disponible" if health_data.get('reddit_available') else "‚ùå No disponible")
    
    # Informaci√≥n de la aplicaci√≥n
    st.subheader("‚ÑπÔ∏è Acerca de la Aplicaci√≥n")
    
    st.markdown("""
    ### Reddit WSB Sentiment Analysis
    
    Esta aplicaci√≥n utiliza un modelo XGBoost entrenado para predecir retornos financieros bas√°ndose en:
    
    - **Datos financieros**: Volumen, Cierres.
    - **An√°lisis de sentimiento**: Posts de Reddit r/wallstreetbets, r/investing, r/criptocurrency, entre otros ...
    - **Indicadores t√©cnicos**: RSI, MACD, SMA, Bollinger Bands
    
    ### Caracter√≠sticas:
    
    - üîÆ Predicciones en tiempo real
    - üìä An√°lisis comparativo de m√∫ltiples acciones
    - üìà Visualizaciones interactivas
    - ü§ñ Modelo XGBoost entrenado
    
    ### Advertencia:
    
    ‚ö†Ô∏è **Las predicciones son solo para fines educativos y no constituyen consejos de inversi√≥n.**
    
    
    ### Hecho con:

    Streamlit, FastAPI, XGBoost, Yahoo Finance, Reddit API
    """
    )
    


elif selected_tab == "üìù An√°lisis de Texto":
    st.header("üìù An√°lisis de Texto Individual")
    
    st.markdown("**Analiza texto individual usando las funciones de limpieza y sentimiento avanzadas**")
    
    # Input de texto
    text_input = st.text_area(
        "Ingresa el texto a analizar",
        placeholder="Ej: $TSLA to the moon! üöÄ This stock is going to explode. Buy the dip!",
        height=150,
        help="Ingresa cualquier texto relacionado con finanzas, trading o inversiones"
    )
    
    if st.button("üîç Analizar Texto", type="primary"):
        if text_input and len(text_input.strip()) > 3:
            with st.spinner("Analizando texto..."):
                analysis_result = analyze_text_api(text_input)
                
                if analysis_result:
                    st.success("‚úÖ An√°lisis completado")
                    
                    # Mostrar resultados
                    col1, col2 = st.columns([2, 1])
                    
                    with col1:
                        st.subheader("üìÑ Texto Original")
                        st.text_area("", value=analysis_result.get('original_text', ''), height=100, disabled=True)
                        
                        st.subheader("üßπ Texto Limpio")
                        st.text_area("", value=analysis_result.get('cleaned_text', ''), height=100, disabled=True)
                    
                    with col2:
                        st.subheader("üìä Estad√≠sticas")
                        text_stats = analysis_result.get('text_stats', {})
                        
                        st.metric("Longitud Original", text_stats.get('original_length', 0))
                        st.metric("Longitud Limpia", text_stats.get('cleaned_length', 0))
                        st.metric("Palabras", text_stats.get('word_count', 0))
                        st.metric("Tickers Encontrados", text_stats.get('ticker_count', 0))
                        
                        if text_stats.get('has_financial_content', False):
                            st.success("‚úÖ Contenido financiero detectado")
                        else:
                            st.info("‚ÑπÔ∏è Sin contenido financiero espec√≠fico")
                    
                    # An√°lisis de sentimiento
                    st.subheader("üòä An√°lisis de Sentimiento")
                    
                    sentiment = analysis_result.get('sentiment_analysis', {})
                    
                    col1, col2, col3 = st.columns(3)
                    
                    with col1:
                        st.subheader("VADER")
                        vader_score = sentiment.get('vader_score', 0)
                        vader_sentiment = sentiment.get('vader_sentiment', 'Neutro')
                        
                        if vader_sentiment == 'Positivo':
                            st.success(f"üìà {vader_sentiment}: {vader_score:.3f}")
                        elif vader_sentiment == 'Negativo':
                            st.error(f"üìâ {vader_sentiment}: {vader_score:.3f}")
                        else:
                            st.info(f"üìä {vader_sentiment}: {vader_score:.3f}")
                        
                        st.metric("Score VADER", f"{vader_score:.3f}")
                    
                    with col2:
                        st.subheader("TextBlob")
                        blob_score = sentiment.get('blob_score', 0)
                        blob_sentiment = sentiment.get('blob_sentiment', 'Neutro')
                        
                        if blob_sentiment == 'Positivo':
                            st.success(f"üìà {blob_sentiment}: {blob_score:.3f}")
                        elif blob_sentiment == 'Negativo':
                            st.error(f"üìâ {blob_sentiment}: {blob_score:.3f}")
                        else:
                            st.info(f"üìä {blob_sentiment}: {blob_score:.3f}")
                        
                        st.metric("Score TextBlob", f"{blob_score:.3f}")
                    
                    with col3:
                        st.subheader("Detalles VADER")
                        st.metric("Positivo", f"{sentiment.get('vader_positive', 0):.3f}")
                        st.metric("Negativo", f"{sentiment.get('vader_negative', 0):.3f}")
                        st.metric("Neutro", f"{sentiment.get('vader_neutral', 0):.3f}")
                    
                    # Tickers encontrados
                    tickers = analysis_result.get('tickers_found', [])
                    if tickers:
                        st.subheader("üéØ Tickers Encontrados")
                        st.write("**Tickers detectados en el texto:**")
                        for ticker in tickers:
                            st.code(f"${ticker}", language="text")
                    else:
                        st.info("‚ÑπÔ∏è No se encontraron tickers en el texto")
                    
                    # Palabras clave del mercado
                    keywords = analysis_result.get('market_keywords', {})
                    if keywords.get('keywords_found'):
                        st.subheader("üîë Palabras Clave del Mercado")
                        st.write("**Palabras clave financieras detectadas:**")
                        for keyword in keywords['keywords_found']:
                            st.badge(keyword)
                        
                        st.metric("Total Keywords", keywords.get('keyword_count', 0))
                    else:
                        st.info("‚ÑπÔ∏è No se encontraron palabras clave del mercado")
                    
                    # Informaci√≥n completa
                    with st.expander("üìÑ An√°lisis Completo (JSON)"):
                        st.json(analysis_result)
                else:
                    st.error("‚ùå No se pudo analizar el texto. Verifica la conexi√≥n con la API.")
        else:
            st.warning("‚ö†Ô∏è Por favor ingresa un texto v√°lido (m√≠nimo 3 caracteres).")
    
    # Ejemplos de texto
    st.subheader("üí° Ejemplos de Texto")
    
    examples = [
        "$TSLA to the moon! üöÄ This stock is going to explode. Buy the dip!",
        "I'm bearish on AAPL. The earnings report was disappointing and I'm selling my position.",
        "Just bought 100 shares of MSFT. Great dividend yield and strong fundamentals.",
        "GME is going to squeeze! Diamond hands! üíéüôå",
        "Market analysis: The current trend suggests a bullish outlook for tech stocks."
    ]
    
    selected_example = st.selectbox("Seleccionar ejemplo:", examples)
    
    if st.button("üìã Usar Ejemplo"):
        st.text_area("", value=selected_example, height=150, key="example_text")

elif selected_tab == "üì± Reddit Sentiment":
    st.header("üì± An√°lisis de Sentimiento Reddit")
    
    # Obtener subreddits disponibles
    available_subreddits_data = get_available_subreddits()
    
    # Input del usuario
    col1, col2, col3 = st.columns([2, 1, 1])
    
    with col1:
        reddit_symbol = st.text_input(
            "S√≠mbolo de la acci√≥n",
            value="TSLA",
            placeholder="Ej: GME, AMC, TSLA",
            help="Ingresa el s√≠mbolo de la acci√≥n para analizar en Reddit",
            key="reddit_symbol"
        ).upper()
    
    with col2:
        posts_limit = st.selectbox("Posts por subreddit", [25, 50, 100, 200], index=2)
    
    with col3:
        analysis_type = st.selectbox(
            "Tipo de an√°lisis", 
            ["B√°sico (WSB)", "Comprehensivo (M√∫ltiples)"],
            index=1,
            help="An√°lisis b√°sico solo en WallStreetBets o comprehensivo en m√∫ltiples subreddits"
        )
    
    # Selector de subreddits para an√°lisis comprehensivo
    if analysis_type == "Comprehensivo (M√∫ltiples)" and available_subreddits_data:
        st.subheader("üéØ Selecci√≥n de Subreddits")
        
        available_subreddits = available_subreddits_data.get('available_subreddits', [])
        descriptions = available_subreddits_data.get('descriptions', {})
        
        # Crear checkboxes para cada subreddit
        selected_subreddits = []
        cols = st.columns(3)
        
        for i, subreddit in enumerate(available_subreddits):
            with cols[i % 3]:
                if st.checkbox(
                    f"r/{subreddit}", 
                    value=subreddit in ["wallstreetbets", "investing", "stocks"],  # Default selection
                    help=descriptions.get(subreddit, "Sin descripci√≥n")
                ):
                    selected_subreddits.append(subreddit)
        
        # Mostrar subreddits seleccionados
        if selected_subreddits:
            st.info(f"üìä Subreddits seleccionados: {', '.join([f'r/{s}' for s in selected_subreddits])}")
        else:
            st.warning("‚ö†Ô∏è Selecciona al menos un subreddit para el an√°lisis")
    else:
        selected_subreddits = ["wallstreetbets"]
    
    if st.button("üìä Analizar Sentimiento", type="primary", key="analyze_reddit"):
        if reddit_symbol:
            with st.spinner(f"Analizando sentimiento de Reddit para {reddit_symbol}..."):
                if analysis_type == "Comprehensivo (M√∫ltiples)" and selected_subreddits:
                    # An√°lisis comprehensivo con m√∫ltiples subreddits
                    subreddits_str = ",".join(selected_subreddits)
                    sentiment_data = get_comprehensive_reddit_analysis(reddit_symbol, subreddits_str, posts_limit)
                    posts_data = None  # No obtenemos posts para an√°lisis comprehensivo por ahora
                else:
                    # An√°lisis b√°sico solo con WallStreetBets
                    sentiment_data = get_reddit_sentiment(reddit_symbol, posts_limit)
                    posts_data = get_reddit_posts(reddit_symbol, 10)
                
                if sentiment_data:
                    st.success("‚úÖ An√°lisis de sentimiento completado")
                    
                    # Verificar si es an√°lisis comprehensivo o b√°sico
                    is_comprehensive = 'subreddit_analysis' in sentiment_data
                    
                    if is_comprehensive:
                        # An√°lisis comprehensivo - m√∫ltiples subreddits
                        st.subheader("üìä An√°lisis Comprehensivo por Subreddit")
                        
                        # M√©tricas agregadas - layout ampliado para mejor visualizaci√≥n
                        st.subheader("üìä M√©tricas Generales")
                        
                        # Primera fila - m√©tricas principales
                        col1, col2, col3, col4, col5 = st.columns(5)
                        
                        with col1:
                            st.metric("üìù Total Posts", sentiment_data.get('total_posts', 0))
                        
                        with col2:
                            st.metric("üè¢ Subreddits", sentiment_data.get('aggregated_metrics', {}).get('subreddits_analyzed', 0))
                        
                        with col3:
                            aggregated = sentiment_data.get('aggregated_metrics', {})
                            st.metric("‚≠ê Score Promedio", f"{aggregated.get('avg_score', 0):.1f}")
                        
                        with col4:
                            st.metric("üëç Upvote Ratio", f"{aggregated.get('avg_upvote_ratio', 0):.2f}")
                        
                        with col5:
                            st.metric("üí¨ Total Comentarios", sentiment_data.get('aggregated_metrics', {}).get('total_comments', 0))
                        
                        # Segunda fila - sentimiento y timestamp
                        col1, col2, col3 = st.columns([2, 1, 1])
                        
                        with col1:
                            sentiment_score = sentiment_data.get('overall_sentiment', 0)
                            sentiment_label = sentiment_data.get('sentiment_label', 'neutral')
                            
                            if sentiment_label == 'bullish':
                                st.success(f"üìà Sentimiento General: {sentiment_label.upper()} ({sentiment_score:.3f})")
                            elif sentiment_label == 'bearish':
                                st.error(f"üìâ Sentimiento General: {sentiment_label.upper()} ({sentiment_score:.3f})")
                            else:
                                st.info(f"üìä Sentimiento General: {sentiment_label.upper()} ({sentiment_score:.3f})")
                        
                        with col2:
                            st.metric("üìä Score Sentimiento", f"{sentiment_score:.3f}")
                        
                        with col3:
                            st.metric("üïí Timestamp", sentiment_data.get('timestamp', 'N/A')[:19])
                        
                        # An√°lisis por subreddit individual
                        st.subheader("üìà An√°lisis Detallado por Subreddit")
                        
                        subreddit_analysis = sentiment_data.get('subreddit_analysis', {})
                        
                        for subreddit_name, analysis in subreddit_analysis.items():
                            with st.expander(f"r/{subreddit_name} - {analysis.get('posts_analyzed', 0)} posts"):
                                # Layout ampliado para mejor visualizaci√≥n
                                col1, col2, col3, col4, col5 = st.columns(5)
                                
                                with col1:
                                    st.metric("üìù Posts", analysis.get('posts_analyzed', 0))
                                
                                with col2:
                                    st.metric("‚≠ê Score Promedio", f"{analysis.get('avg_score', 0):.1f}")
                                
                                with col3:
                                    st.metric("üëç Upvote Ratio", f"{analysis.get('avg_upvote_ratio', 0):.2f}")
                                
                                with col4:
                                    st.metric("üí¨ Comentarios", analysis.get('total_comments', 0))
                                
                                with col5:
                                    subreddit_sentiment = analysis.get('sentiment_score', 0)
                                    if subreddit_sentiment > 0.1:
                                        st.success(f"üìà {subreddit_sentiment:.3f}")
                                    elif subreddit_sentiment < -0.1:
                                        st.error(f"üìâ {subreddit_sentiment:.3f}")
                                    else:
                                        st.info(f"üìä {subreddit_sentiment:.3f}")
                                    
                                    st.metric("üìä Sentiment Score", f"{subreddit_sentiment:.3f}")
                    else:
                        # An√°lisis b√°sico - solo WallStreetBets (layout ampliado)
                        st.subheader("üìä M√©tricas de WallStreetBets")
                        
                        # Primera fila - m√©tricas principales
                        col1, col2, col3, col4, col5 = st.columns(5)
                        
                        with col1:
                            st.metric("üìù Posts Analizados", sentiment_data.get('posts_analyzed', 0))
                        
                        with col2:
                            st.metric("‚≠ê Score Promedio", f"{sentiment_data.get('avg_score', 0):.1f}")
                        
                        with col3:
                            st.metric("üëç Upvote Ratio", f"{sentiment_data.get('avg_upvote_ratio', 0):.2f}")
                        
                        with col4:
                            st.metric("üí¨ Total Comentarios", sentiment_data.get('total_comments', 0))
                        
                        with col5:
                            st.metric("üè¢ Subreddit", sentiment_data.get('subreddit', 'N/A'))
                        
                        # Segunda fila - sentimiento y timestamp
                        col1, col2, col3 = st.columns([2, 1, 1])
                        
                        with col1:
                            sentiment_score = sentiment_data.get('sentiment_score', 0)
                            sentiment_label = sentiment_data.get('sentiment_label', 'neutral')
                            
                            if sentiment_label == 'bullish':
                                st.success(f"üìà Sentimiento: {sentiment_label.upper()} ({sentiment_score:.3f})")
                            elif sentiment_label == 'bearish':
                                st.error(f"üìâ Sentimiento: {sentiment_label.upper()} ({sentiment_score:.3f})")
                            else:
                                st.info(f"üìä Sentimiento: {sentiment_label.upper()} ({sentiment_score:.3f})")
                        
                        with col2:
                            st.metric("üìä Score Sentimiento", f"{sentiment_score:.3f}")
                        
                        with col3:
                            st.metric("üïí Timestamp", sentiment_data.get('timestamp', 'N/A')[:19])
                        
                        # Nuevas m√©tricas de an√°lisis avanzado
                        if sentiment_data.get('vader_score') is not None:
                            st.subheader("üî¨ An√°lisis Avanzado")
                            
                            # Layout ampliado para an√°lisis avanzado
                            col1, col2, col3, col4 = st.columns(4)
                            
                            with col1:
                                st.metric("üìä VADER Score", f"{sentiment_data.get('vader_score', 0):.3f}")
                            
                            with col2:
                                st.metric("üìà TextBlob Score", f"{sentiment_data.get('blob_score', 0):.3f}")
                            
                            with col3:
                                tickers_found = sentiment_data.get('tickers_found', [])
                                if tickers_found:
                                    st.write("**üéØ Tickers encontrados:**")
                                    for ticker in tickers_found[:5]:  # Mostrar solo los primeros 5
                                        st.code(f"${ticker}", language="text")
                                else:
                                    st.info("Sin tickers detectados")
                            
                            with col4:
                                keywords = sentiment_data.get('market_keywords', [])
                                if keywords:
                                    st.write("**üîë Keywords del mercado:**")
                                    for keyword in keywords[:5]:  # Mostrar solo los primeros 5
                                        st.badge(keyword)
                                else:
                                    st.info("Sin keywords detectadas")
                            
                    
                    # Gr√°fico de sentimiento
                    st.subheader("üìä Visualizaci√≥n del Sentimiento")
                    
                    if is_comprehensive:
                        # Gr√°fico para an√°lisis comprehensivo
                        aggregated = sentiment_data.get('aggregated_metrics', {})
                        
                        metrics_data = {
                            'M√©trica': ['Score Promedio', 'Upvote Ratio', 'Score Sentimiento'],
                            'Valor': [
                                aggregated.get('avg_score', 0),
                                aggregated.get('avg_upvote_ratio', 0) * 100,
                                abs(sentiment_data.get('overall_sentiment', 0)) * 100
                            ]
                        }
                        
                        fig = px.bar(
                            pd.DataFrame(metrics_data),
                            x='M√©trica',
                            y='Valor',
                            title=f"M√©tricas Agregadas de Sentimiento - {reddit_symbol}",
                            color='Valor',
                            color_continuous_scale="RdYlGn"
                        )
                        st.plotly_chart(fig, use_container_width=True)
                        
                        # Gr√°fico comparativo por subreddit
                        subreddit_analysis = sentiment_data.get('subreddit_analysis', {})
                        if subreddit_analysis:
                            subreddit_data = []
                            for subreddit_name, analysis in subreddit_analysis.items():
                                subreddit_data.append({
                                    'Subreddit': f"r/{subreddit_name}",
                                    'Posts': analysis.get('posts_analyzed', 0),
                                    'Sentiment Score': analysis.get('sentiment_score', 0)
                                })
                            
                            if subreddit_data:
                                df_subreddit = pd.DataFrame(subreddit_data)
                                
                                fig2 = px.bar(
                                    df_subreddit,
                                    x='Subreddit',
                                    y='Sentiment Score',
                                    title=f"Sentimiento por Subreddit - {reddit_symbol}",
                                    color='Sentiment Score',
                                    color_continuous_scale="RdYlGn"
                                )
                                st.plotly_chart(fig2, use_container_width=True)
                    else:
                        # Gr√°fico para an√°lisis b√°sico
                        metrics_data = {
                            'M√©trica': ['Score Promedio', 'Upvote Ratio', 'Score Sentimiento'],
                            'Valor': [
                                sentiment_data.get('avg_score', 0),
                                sentiment_data.get('avg_upvote_ratio', 0) * 100,
                                abs(sentiment_data.get('sentiment_score', 0)) * 100
                            ]
                        }
                        
                        fig = px.bar(
                            pd.DataFrame(metrics_data),
                            x='M√©trica',
                            y='Valor',
                            title=f"M√©tricas de Sentimiento - {reddit_symbol}",
                            color='Valor',
                            color_continuous_scale="RdYlGn"
                        )
                        st.plotly_chart(fig, use_container_width=True)
                    
                    # Posts populares
                    if posts_data and posts_data.get('posts'):
                        st.subheader("üî• Posts Populares")
                        
                        for i, post in enumerate(posts_data['posts'][:5], 1):
                            with st.expander(f"#{i} {post['title'][:80]}..."):
                                col1, col2, col3 = st.columns([2, 1, 1])
                                
                                with col1:
                                    st.write(f"**Autor:** {post['author']}")
                                    st.write(f"**Contenido:** {post['selftext']}")
                                    st.write(f"**Fecha:** {post['created_utc'][:19]}")
                                    
                                    # A√±adir enlace directo al post de Reddit
                                    if 'url' in post and post['url']:
                                        st.write(f"**Enlace:** [Ver post en Reddit]({post['url']})")
                                    
                                    # Mostrar an√°lisis de sentimiento del post si est√° disponible
                                    if 'sentiment_analysis' in post:
                                        sentiment = post['sentiment_analysis']
                                        st.write("**An√°lisis de Sentimiento:**")
                                        
                                        col_vader, col_blob = st.columns(2)
                                        with col_vader:
                                            vader_sentiment = sentiment.get('vader_sentiment', 'Neutro')
                                            vader_score = sentiment.get('vader_score', 0)
                                            if vader_sentiment == 'Positivo':
                                                st.success(f"VADER: {vader_sentiment} ({vader_score:.3f})")
                                            elif vader_sentiment == 'Negativo':
                                                st.error(f"VADER: {vader_sentiment} ({vader_score:.3f})")
                                            else:
                                                st.info(f"VADER: {vader_sentiment} ({vader_score:.3f})")
                                        
                                        with col_blob:
                                            blob_sentiment = sentiment.get('blob_sentiment', 'Neutro')
                                            blob_score = sentiment.get('blob_score', 0)
                                            if blob_sentiment == 'Positivo':
                                                st.success(f"TextBlob: {blob_sentiment} ({blob_score:.3f})")
                                            elif blob_sentiment == 'Negativo':
                                                st.error(f"TextBlob: {blob_sentiment} ({blob_score:.3f})")
                                            else:
                                                st.info(f"TextBlob: {blob_sentiment} ({blob_score:.3f})")
                                    
                                    # Mostrar tickers encontrados si est√°n disponibles
                                    if 'tickers_found' in post and post['tickers_found']:
                                        st.write("**Tickers:**")
                                        for ticker in post['tickers_found']:
                                            st.code(f"${ticker}", language="text")
                                
                                with col2:
                                    st.metric("Score", post['score'])
                                    st.metric("Comentarios", post['num_comments'])
                                    st.metric("Upvote Ratio", f"{post['upvote_ratio']:.2f}")
                                
                                with col3:
                                    # Boton ver en reddit
                                    st.markdown(
                                        f'''
                                        <a href="{post["url"]}" target="_blank">
                                            <button style="width:100%; background-color:#d32f2f; color:white; border:none; padding:8px 0; border-radius:4px; font-weight:bold; cursor:pointer;">
                                                üîó Ver en Reddit
                                            </button>
                                        </a>
                                        ''',
                                        unsafe_allow_html=True
                                    )
                                    
                                    # Mostrar texto limpio si est√° disponible
                                    if 'text_cleaned' in post and post['text_cleaned']:
                                        with st.expander("Ver texto limpio"):
                                            st.text(post['text_cleaned'])
                    
                    # Informaci√≥n completa
                    with st.expander("üìÑ Datos Completos del An√°lisis"):
                        st.json(sentiment_data)
                        if posts_data:
                            st.json(posts_data)
                else:
                    st.error("‚ùå No se pudo obtener el an√°lisis de sentimiento. Verifica el s√≠mbolo y la conexi√≥n.")
        else:
            st.warning("‚ö†Ô∏è Por favor ingresa un s√≠mbolo v√°lido.")


